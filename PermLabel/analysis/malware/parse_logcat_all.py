import json
import glob
import copy
import os.path


def read_request(request_path="request.json"):
    """
        This function is used to load mapping of SHA256 values to package names
    """
    if os.path.exists(request_path):
        with open(request_path) as req:
            request = json.load(req)
    else:
        request = dict()

    return request


def process_pkg_map(path='pkg_sha_maps.json'):
    """
        This function is used to load mapping of SHA256 values to package names
    """
    with open(path) as d:
        pkgDict = json.load(d)
    return pkgDict


def process_group_map(map, path="perm_group_map.json"):
    """
        This function is used to merge historic permission-group mapping with the mapping of current app
    """
    if os.path.exists(path):
        with open(path) as d:
            groupDict = json.load(d)
    else:
        groupDict = dict()
    for i in map:
        if i not in groupDict:
            groupDict[i] = map[i]
    with open(path, 'w') as saved_maps:
        json.dump(groupDict, saved_maps)


def read_logcat(mType, sha, pkg, idx):
    """
        This function read_logcat(pkg, idx) is used to read the contents from logcat.txt.
        And extract the PID lists that are generated by our observed app (use the matching of package name).
    """
    pid = dict()
    path_to_folder_logcat = "logcats/" + mType + "/" + sha + "_" + idx + "_logcat.txt"
    with open(path_to_folder_logcat, 'r', encoding='UTF-8') as f:
        lines = f.readlines()
        for ct, line in enumerate(lines):
            if ' package =' + pkg in line:
                pid[line.split()[-1].strip()] = ct
                print(line.split()[-1].strip())
        return lines, pid


def obtain_uid(logs, pid, pkg):
    """
        This function is used to obtain the UID of current tested app
    """
    uid = 0

    for ct, line in enumerate(logs):
        if uid != 0:
            break
        for i in pid.keys():
            if ' package =' + pkg in line and "PermLabel package =" not in line:
                uid = int(line.split(' PermLabel ')[1].split(' package =')[0].strip())

            #if 'PermLabel package =' in line and "uid ->" in line:
                #uid = int(line.split(' ')[-1].strip())

            if i + ' PermLabel' in line and ct >= pid[i]:
                if 'AMS.checkPermission' in line:
                    uid = int(line.split('uid =')[1].split('; ')[0].strip())
    return uid


def parse(pkg, sha, mType, idx, logs, pid, perm_group_pm):
    """
        This function parse(pkg, idx, logs, pid) first extracts the logs from logcat.txt and write to logcat_filtered.txt
        Then, for rach line matching specific log label (ex. 'normal_permissions', 'AMS', 'requestPermissions'..)
        We process the line and write the permission information to dictionary
    """
    AMS = dict()
    AMS_normal = dict()
    request_permissions = dict()
    request_perm_groups = dict()
    perm_group_maps = dict()
    label_dict = dict()
    label_dict['Declared'] = dict()
    label_dict['Declared']['Normal'] = list()
    label_dict['Declared']['Dangerous'] = list()
    label_dict['Declared']['All'] = list()
    uid = obtain_uid(logs, pid, pkg)
    print(sha)
    print(uid)
    print(pid)

    w_path = "logcats_filtered/" + mType + "/" + sha + "_" + idx + "_logcat_filtered.txt"
    with open(w_path, 'w', encoding='UTF-8') as f2:
        for ct, line in enumerate(logs):
            for i in pid.keys():
                # For newer testing, we only need to check if 'PermLabel' + uid in line
                # However, for backward-compatibility, we add uid checking in AMS.checkPermission and requestPermissions
                # Those permission declarations need not uid checking,
                #       'all_declared permissions'
                #       'normal_permissions'
                #       'dangerous_permissions'
                #       'permission_group_mapping'
                # because they only generate at the first loading of tested apps.
                if i + ' PermLabel' in line and ct >= pid[i]:
                    f2.writelines(line)

                    if 'all_declared permissions' in line:
                        perm_list = line.split('=')[1].strip().split()
                        label_dict['Declared']['All'] = [len(perm_list), perm_list]
                    elif 'normal_permissions' in line:
                        n_perm_list = line.split('=')[1].strip().split()
                        label_dict['Declared']['Normal'] = [len(n_perm_list), n_perm_list]
                    elif 'dangerous_permissions' in line:
                        d_perm_list = line.split('=')[1].strip().split()
                        label_dict['Declared']['Dangerous'] = [len(d_perm_list), d_perm_list]
                    elif 'permission_group_mapping' in line:
                        perm = line.split('=')[1].split()[0]
                        group = line.split('=')[1].split()[1]
                        perm_group_maps[perm] = group
                    elif 'AMS.checkPermission' in line:
                        target_uid = int(line.split('uid =')[1].split(';')[0].strip())
                        # This condition is used to filter out those logs generated by different apps
                        # (reusing the same PID during the Droidbot testing)
                        if uid == target_uid:
                            perm = line.split('permName:')[1].split(';')[0].strip()
                            res = line.split('res =')[1].split(';')[0].strip()
                            perm_type = int(line.split('permName:')[1].split('type =')[1].split(';')[0].strip())
                            # Save all normal permissions to AMS,
                            # including type 1 permissions (Runtime) and type 0 permissions (Install-time)
                            # Notice that the runtime permissions have already been filtered by monitoring script
                            if perm not in AMS:
                                AMS[perm] = dict()
                                AMS[perm]['res'] = res
                                AMS[perm]['perm_type'] = perm_type
                                AMS[perm]['count'] = ct

                            # For type 0 permissions (Install-time)
                            if perm_type == 0 and perm not in AMS_normal:
                                # Filter out self-checking normal permissions and
                                # only save the checkCallingPermission normal permissions to AMS_normal
                                checked_pid = line.split("LSPosed-Bridge:")[1].split("PermLabel")[0].strip()
                                called_pid = line.split("Binder.getCallingPid() =")[1].split("; uid")[0].strip()
                                if checked_pid != called_pid:
                                    AMS_normal[perm] = dict()
                                    AMS_normal[perm]['res'] = res
                                    AMS_normal[perm]['perm_type'] = perm_type
                                    AMS_normal[perm]['count'] = ct
                                elif checked_pid == called_pid and 'stacktrace' in line:
                                    n = 1
                                    # Genymotion generates 'LSPHooker_' instead of 'LspHooker_' in real device
                                    while 'LSPHooker_.checkPermission' not in logs[ct+n] and 'LspHooker_.checkPermission' not in logs[ct+n]:
                                        n += 1
                                    if logs[ct+n+1] == '\n':
                                        n += 1
                                    if 'Stub.onTransact' not in logs[ct+n+1]:
                                        print("n+1", n+1, "; logs[ct+n+1]", logs[ct+n+1])
                                        print("res", res)
                                        AMS_normal[perm] = dict()
                                        AMS_normal[perm]['res'] = res
                                        AMS_normal[perm]['perm_type'] = perm_type
                                        AMS_normal[perm]['count'] = ct

                    elif 'requestPermissions' in line or 'startActivityAsUser permName' in line:
                        # In the newer testing, we add UID after PermLabel as [PID] PermLabel [UID]
                        # However, we need to make this code backward compatible
                        # The condition 'PermLabel requestPermissions' not in line means this is the newer testing
                        if 'PermLabel requestPermissions' not in line:
                            if 'PermLabel ' + str(uid) not in line:
                                continue
                        perm = line.split('permName:')[1].split(';')[0].strip()

                        if perm in perm_group_maps:
                            group = perm_group_maps[perm].capitalize()
                        elif perm in perm_group_pm:
                            # Some apps request permissions for install-time permissions
                            # So we first check if this permission is in the per_group_perm
                            # If not, it is probably the install-time permission
                            # We can ignore it directly
                            group = perm_group_pm[perm].capitalize()

                        if perm not in request_permissions:
                            request_permissions[perm] = ct
                        if group not in request_perm_groups:
                            request_perm_groups[group] = ct
                        '''
                        if perm in perm_group_maps:
                            group = perm_group_maps[perm]
                            if group not in request_perm_groups:
                                request_perm_groups[group] = ct
                        if perm not in request_permissions:
                            request_permissions[perm] = ct
                        '''

    process_group_map(perm_group_maps)
    return AMS, AMS_normal, request_permissions, request_perm_groups, label_dict


def label_perm(AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_mapping, label, prev_request):
    """
        This function label_perm() labels each required permission by referencing the information of
        [AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_mapping, label] accordingly.
        The typical label outputs are saved in the:
            label['Droidbot-obtained']['Normal'] = dict() --> Policy: Log all normal permissions triggering AMS.
            label['Droidbot-obtained']['Dangerous'] = dict() --> Policy: Filter out the checkSelfPermission.
        The adapted version that filters out the self-checked normal permissions is saved in the:
            label['Droidbot-obtained']['filter_normal_self'] --> Policy: Filter out the checkSelfPermission.
        The adapted version that adds triggering requestPermission is saved in the:
            label['Droidbot-obtained']['add_dangerous_request'] --> Policy: Add the requestPermission.
    """
    label['Droidbot-obtained'] = dict()
    label['Droidbot-obtained']['Normal'] = dict()
    label['Droidbot-obtained']['Dangerous'] = dict()
    label['Droidbot-obtained']['filter_normal_self'] = dict()
    label['Droidbot-obtained']['filter_normal_self_strict'] = dict()
    label['Droidbot-obtained']['add_dangerous_request'] = dict()

    for perm in AMS:
        if AMS[perm]['perm_type'] == 1:
            print(perm)
            print(prev_request[0])
            if perm in perm_group_mapping:
                group = perm_group_mapping[perm].capitalize()
            else:
                group = ''
            print(group)
            print(prev_request[1])
            print(label['Declared']['All'])
            #if AMS[perm]['res'] == '-1':
            if perm not in label['Declared']['All'][1]:
                if perm in requestPermissions.keys() and AMS[perm]['count'] > requestPermissions[perm]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 1
                elif group in requestPermGroups.keys() and AMS[perm]['count'] > requestPermGroups[group]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 1
                elif group in prev_request[1]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 1
                else:
                    label['Droidbot-obtained']['Dangerous'][perm] = 3
            else:
                if perm in requestPermissions.keys() and AMS[perm]['count'] > requestPermissions[perm]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 0
                elif group in requestPermGroups.keys() and AMS[perm]['count'] > requestPermGroups[group]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 0
                elif group in prev_request[1]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 0
                else:
                    label['Droidbot-obtained']['Dangerous'][perm] = 2
        else:
            if perm not in label['Declared']['All'][1]:
                label['Droidbot-obtained']['Normal'][perm] = 1
            else:
                label['Droidbot-obtained']['Normal'][perm] = 0

    # This block is to filter out those "abnormal permission labels" that are triggered by checkSelfPermission
    for perm in label['Droidbot-obtained']['Normal']:
        if label['Droidbot-obtained']['Normal'][perm] == 0:
            label['Droidbot-obtained']['filter_normal_self'][perm] = 0
        elif label['Droidbot-obtained']['Normal'][perm] == 1 and perm in AMS_normal:
            label['Droidbot-obtained']['filter_normal_self'][perm] = 1

    # This block is used to generate strictly filtering out checkSelfPermission
    for perm in AMS_normal:
        if AMS_normal[perm]['perm_type'] == 0:
            if AMS_normal[perm]['res'] == '-1':
                label['Droidbot-obtained']['filter_normal_self_strict'][perm] = 1
            else:
                label['Droidbot-obtained']['filter_normal_self_strict'][perm] = 0

    label['Droidbot-obtained']['add_dangerous_request'] = copy.deepcopy(label['Droidbot-obtained']['Dangerous'])
    for perm in requestPermissions:
        if perm not in label['Droidbot-obtained']['Dangerous'] and perm not in label['Droidbot-obtained']['Normal']:
            if perm in label['Declared']['All'][1]:
                label['Droidbot-obtained']['add_dangerous_request'][perm] = 0
            else:
                label['Droidbot-obtained']['add_dangerous_request'][perm] = 1

    return label


if __name__ == '__main__':
    # Create folders if not exist
    if not os.path.exists("logcats_filtered/"):
        os.makedirs("logcats_filtered/")
    if not os.path.exists("labels/"):
        os.makedirs("labels/")

    # Read all mappings between SHA and package name
    pkg_sha_map = process_pkg_map()

    # Load the global permission and group mappings
    with open('perm_group_pm.json') as map:
        perm_group_pm = json.load(map)

    type_list = glob.glob("logcats\\*")
    print(type_list)
    for type_path in type_list:
        type_name = type_path.split("\\")[-1]
        print(type_name)
        if not os.path.exists("logcats_filtered/"+type_name):
            os.makedirs("logcats_filtered/"+type_name)
        if not os.path.exists("labels/"+type_name):
            os.makedirs("labels/"+type_name)

        # Read all the log files under logcats/
        logcats_lst = glob.glob(type_path+"\\*.txt")

        pkg_list = set([(i.split("\\")[-1].split("_")[0]).upper() for i in logcats_lst])
        print(pkg_list)
        for sha in pkg_list:
            for index in ['0', '1']:
                logcat_path = "logcats\\%s\\%s_%s_logcat.txt" % (type_name, sha, index)
                if not os.path.exists(logcat_path):
                    continue

                # Read requests from file 'request.json'
                perm_requests = read_request()

                # Extract package name and index from the file name
                # i represents file path, so it will be like logcats\pkg_idx_logcat.txt
                #sha = (i.split("\\")[-1].split("_")[0]).upper() # The sample file name is lower-case, but the list is upper-case.
                pkgName = pkg_sha_map[sha]

                '''
                # This code block is used to control the index 0 logcat file to be parsed first
                # If key exists sha, it means index 0 logcat file has been parsed
                if sha in perm_requests:
                    index = '1'
                else:
                    index = '0'
                '''

                # index = i.split("\\")[-1].split("_")[1]
                chk_path = "labels\\%s\\%s_%s_label.json" % (type_name, sha, index)
                if os.path.exists(chk_path):
                    continue

                lines, pidList = read_logcat(type_name, sha, pkgName, index)
                AMS, AMS_normal, requestPermissions, requestPermGroups, label = parse(pkgName, sha, type_name, index, lines, pidList, perm_group_pm)
                print("index", index)

                # If parsing index 1 logcat, we should read the requested permissions and groups from the perm_requests
                # Because if the permission or permission group is requested in the logcat_0 file,
                # then it should be referenced by the logcat_1 file
                if index == '1':
                    prev_requests = perm_requests[sha]
                else:
                    prev_requests = [[], []]
                    perm_requests[sha] = [list(requestPermissions.keys()), list(requestPermGroups.keys())]
                print(prev_requests)
                label_all = label_perm(AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_pm, label, prev_requests)

                label_path = "labels/" + type_name + '/' + sha + '_' + index + '_label.json'

                with open(label_path, 'w') as saved_labels:
                    json.dump(label_all, saved_labels, indent=4)

                # Save requestPermissions and groups
                if index == '0':
                    with open("request.json", "w") as req_save:
                        json.dump(perm_requests, req_save, indent=4)
