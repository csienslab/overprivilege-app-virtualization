"""
This code is used to parse the raw logcats generated by Droidbot testing
Input:
  - logcats/[app store]/[pkg]_logcat.txt
Output:
  - labels/[app store]/[pkg]_label.json
  - logcats_filtered/[app store]/[pkg]_logcat_filtered.txt
"""

import json
import glob
import copy
import os.path


def read_request(request_path="request.json"):
    """
        This function is used to load mapping of SHA256 values to package names
    """
    if os.path.exists(request_path):
        with open(request_path) as req:
            request = json.load(req)
    else:
        request = dict()

    return request


def process_group_map(map, path="perm_group_map.json"):
    """
        This function is used to merge historic permission-group mapping with the mapping of current app
    """
    if os.path.exists(path):
        with open(path) as d:
            groupDict = json.load(d)
    else:
        groupDict = dict()
    for i in map:
        if i not in groupDict:
            groupDict[i] = map[i]
    with open(path, 'w') as saved_maps:
        json.dump(groupDict, saved_maps)
    return groupDict


def read_logcat(app_source, pkg):
    """
        This function read_logcat(pkg) is used to read the contents from logcats.txt.
        And extract the PID lists that are generated by our observed app (use the matching of package name).
    """
    pid = dict()
    path_to_folder_logcat = "logcats/%s/%s_logcat.txt" % (app_source, pkg)
    with open(path_to_folder_logcat, 'r', encoding='UTF-8') as f:
        lines = f.readlines()
        for ct, line in enumerate(lines):
            # if 'PermLabel package =' + pkg in line:
            # LSPosed-Bridge: 8533 PermLabel 10117 package =com.bilibili.fgo.qihoo 8533
            if ' package =' + pkg in line:
                pid[line.split()[-1].strip()] = ct
                #print(line.split()[-1].strip())
        return lines, pid


def obtain_uid(logs, pid, pkg):
    """
        This function is used to obtain the UID of current tested app
    """
    uid = 0

    for ct, line in enumerate(logs):
        if uid != 0:
            break
            # This is used to break the Method 2, because UID remains the same. We just want to extract the UID
            # from the most recent line from the 'PermLabel package =' log line
        for i in pid.keys():
            # Method 1 (new): we directly add UID information in the 'PermLabel package =' log line
            if ' package =' + pkg in line and "PermLabel package =" not in line:
                uid = int(line.split(' PermLabel ')[1].split(' package =')[0].strip())
            #if 'PermLabel package =' in line and "uid ->" in line:
                #uid = int(line.split(' ')[-1].strip())

            # Method 2 (backward compatibility): we
            if i + ' PermLabel' in line and ct >= pid[i]:
                if 'AMS.checkPermission' in line:
                    uid = int(line.split('uid =')[1].split('; ')[0].strip())
    return uid


def parse(source, pkg, logs, pid):
    """
        This function parse(pkg, idx, logs, pid) first extracts the logs from logcats.txt and write to logcat_filtered.txt
        Then, for rach line matching specific log label (ex. 'normal_permissions', 'AMS', 'requestPermissions'..)
        We process the line and write the permission information to dictionary
        logs :: contents of logcats.txt
        pid :: dicts of app's process ID
    """
    AMS = dict()
    AMS_normal = dict()
    request_permissions = dict()
    request_perm_groups = dict()
    perm_group_maps = dict()
    label_dict = dict()
    label_dict['Declared'] = dict()
    label_dict['Declared']['Normal'] = list()
    label_dict['Declared']['Dangerous'] = list()
    label_dict['Declared']['All'] = list()
    uid = obtain_uid(logs, pid, pkg)
    print("uid", uid)
    print("pid", pid)

    w_path = "logcats_filtered/" + source_list + "/" + pkg + "_logcat_filtered.txt"
    with open(w_path, 'w', encoding='UTF-8') as f2:
        for ct, line in enumerate(logs):
            for i in pid.keys():
                # For newer testing, we only need to check if 'PermLabel' + uid in line
                # However, for backward-compatibility, we add uid checking in AMS.checkPermission and requestPermissions
                # Those permission declarations need not uid checking,
                #       'all_declared permissions'
                #       'normal_permissions'
                #       'dangerous_permissions'
                #       'permission_group_mapping'
                # because they only generate at the first loading of tested apps.
                if i + ' PermLabel' in line and ct >= pid[i]:
                    f2.writelines(line)

                    if 'all_declared permissions' in line:
                        all_perm_list = line.split('=')[1].strip().split()
                        label_dict['Declared']['All'] = [len(all_perm_list), all_perm_list]
                    if 'normal_permissions' in line:
                        n_perm_list = line.split('=')[1].strip().split()
                        label_dict['Declared']['Normal'] = [len(n_perm_list), n_perm_list]
                    elif 'dangerous_permissions' in line:
                        d_perm_list = line.split('=')[1].strip().split()
                        label_dict['Declared']['Dangerous'] = [len(d_perm_list), d_perm_list]
                    elif 'permission_group_mapping' in line:
                        perm = line.split('=')[1].split()[0]
                        group = line.split('=')[1].split()[1]
                        print(perm, group)
                        perm_group_maps[perm] = group
                    elif 'AMS.checkPermission' in line:
                        target_uid = int(line.split('uid =')[1].split(';')[0].strip())
                        # This condition is used to filter out those logs generated by different apps
                        # (reusing the same PID during the Droidbot testing)
                        if uid == target_uid:
                            perm = line.split('permName:')[1].split(';')[0].strip()
                            res = line.split('res =')[1].split(';')[0].strip()
                            perm_type = int(line.split('permName:')[1].split('type =')[1].split(';')[0].strip())
                            # This timestamp is used to map the corresponding activity in the utg.js
                            timestamp = line.split()[0] + '_' + "".join(line.split()[1].split('.')[0].split(":"))
                            # Save all normal permissions to AMS,
                            # including type 1 permissions (Runtime) and type 0 permissions (Install-time)
                            # Notice that the runtime permissions have already been filtered by monitoring script
                            if perm not in AMS:
                                AMS[perm] = dict()
                                AMS[perm]['res'] = res
                                AMS[perm]['perm_type'] = perm_type
                                AMS[perm]['count'] = ct
                                AMS[perm]['timestamp'] = timestamp

                            # For type 0 permissions (Install-time)
                            if perm_type == 0 and perm not in AMS_normal:
                                # Filter out self-checking normal permissions and
                                # only save the checkCallingPermission normal permissions to AMS_normal
                                # Example:
                                # LSPosed-Bridge: 8533 PermLabel 10117 AMS.checkPermission:
                                # Binder.getCallingPid() = 8533; uid = 10117; Binder.getCallingUid() = 10117;
                                checked_pid = line.split("LSPosed-Bridge:")[1].split("PermLabel")[0].strip()
                                called_pid = line.split("Binder.getCallingPid() =")[1].split("; uid")[0].strip()
                                if checked_pid != called_pid:
                                    AMS_normal[perm] = dict()
                                    AMS_normal[perm]['res'] = res
                                    AMS_normal[perm]['perm_type'] = perm_type
                                    AMS_normal[perm]['count'] = ct
                                elif checked_pid == called_pid and 'stacktrace' in line:
                                    n = 1
                                    while 'LSPHooker_.checkPermission' not in logs[ct+n] and 'LspHooker_.checkPermission' not in logs[ct+n]:
                                        n += 1
                                    if logs[ct+n+1] == '\n':
                                        n += 1
                                    if 'Stub.onTransact' not in logs[ct+n+1]:
                                        AMS_normal[perm] = dict()
                                        AMS_normal[perm]['res'] = res
                                        AMS_normal[perm]['perm_type'] = perm_type
                                        AMS_normal[perm]['count'] = ct
                        else:
                            print("PID reuse and UID is ", target_uid)
                    elif 'requestPermissions' in line or 'startActivityAsUser permName' in line:
                        if 'PermLabel requestPermissions' not in line:
                            if 'PermLabel ' + str(uid) not in line:
                                continue
                        perm = line.split('permName:')[1].split(';')[0].strip()
                        if perm in perm_group_maps:
                            group = perm_group_maps[perm].capitalize()
                        elif perm in perm_group_pm:
                            # Some apps request permissions for install-time permissions
                            # So we first check if this permission is in the per_group_perm
                            # If not, it is probably the install-time permission
                            # We can ignore it directly
                            group = perm_group_pm[perm].capitalize()

                        if perm not in request_permissions:
                            # This timestamp is used to map the corresponding activity in the utg.js
                            request_permissions[perm] = dict()
                            timestamp = line.split()[0] + '_' + "".join(line.split()[1].split('.')[0].split(":"))
                            request_permissions[perm]['count'] = ct
                            request_permissions[perm]['timestamp'] = timestamp
                            #request_permissions[perm] = ct
                        if group not in request_perm_groups:
                            request_perm_groups[group] = ct

    merged_map = process_group_map(perm_group_maps)
    return AMS, AMS_normal, request_permissions, request_perm_groups, merged_map, label_dict


def label_perm(AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_mapping, label):
    """
        This function label_perm() labels each required permission by referencing the information of
        [AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_mapping, label] accordingly.
        The typical label outputs are saved in the:
            label['Droidbot-obtained']['Normal'] = dict() --> Policy: Log all normal permissions triggering AMS.
            label['Droidbot-obtained']['Dangerous'] = dict() --> Policy: Filter out the checkSelfPermission.
        The adapted version that filters out the self-checked normal permissions is saved in the:
            label['Droidbot-obtained']['filter_normal_self'] --> Policy: Filter out the checkSelfPermission.
        The adapted version that adds triggering requestPermission is saved in the:
            label['Droidbot-obtained']['add_dangerous_request'] --> Policy: Add the requestPermission.
    """
    label['Droidbot-obtained'] = dict()
    label['Droidbot-obtained']['Normal'] = dict()
    label['Droidbot-obtained']['Dangerous'] = dict()
    label['Droidbot-obtained']['filter_normal_self'] = dict()
    label['Droidbot-obtained']['filter_normal_self_strict'] = dict()
    label['Droidbot-obtained']['add_dangerous_request'] = dict()

    trace = dict()

    for perm in AMS:
        '''
        if 'GET_ACCOUNTS' in perm:
            continue
        '''
        if AMS[perm]['perm_type'] == 1:
            group = perm_group_mapping[perm].capitalize()
            if perm not in label['Declared']['All'][1] and perm not in label['Declared']['Dangerous'][1]:
                trace[perm] = AMS[perm]['timestamp']
                if perm in requestPermissions.keys() and AMS[perm]['count'] > requestPermissions[perm]['count']:
                    label['Droidbot-obtained']['Dangerous'][perm] = 1
                elif group in requestPermGroups.keys() and AMS[perm]['count'] > requestPermGroups[group]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 1
                else:
                    label['Droidbot-obtained']['Dangerous'][perm] = 3
            else:
                if perm in requestPermissions.keys() and AMS[perm]['count'] > requestPermissions[perm]['count']:
                    label['Droidbot-obtained']['Dangerous'][perm] = 0
                elif group in requestPermGroups.keys() and AMS[perm]['count'] > requestPermGroups[group]:
                    label['Droidbot-obtained']['Dangerous'][perm] = 0
                else:
                    trace[perm] = AMS[perm]['timestamp']
                    label['Droidbot-obtained']['Dangerous'][perm] = 2
        else:
            if perm not in label['Declared']['All'][1] and perm not in label['Declared']['Normal'][1]:
                trace[perm] = AMS[perm]['timestamp']
                label['Droidbot-obtained']['Normal'][perm] = 1
            else:
                label['Droidbot-obtained']['Normal'][perm] = 0

    # This block is to filter out those "abnormal permission labels" that are triggered by checkSelfPermission
    for perm in label['Droidbot-obtained']['Normal']:
        if label['Droidbot-obtained']['Normal'][perm] == 0:
            label['Droidbot-obtained']['filter_normal_self'][perm] = 0
        elif label['Droidbot-obtained']['Normal'][perm] == 1 and perm in AMS_normal:
            label['Droidbot-obtained']['filter_normal_self'][perm] = 1

    # This block is used to generate strictly filtering out checkSelfPermission
    for perm in AMS_normal:
        if AMS_normal[perm]['perm_type'] == 0:
            if AMS_normal[perm]['res'] == '-1':
                label['Droidbot-obtained']['filter_normal_self_strict'][perm] = 1
            else:
                label['Droidbot-obtained']['filter_normal_self_strict'][perm] = 0

    label['Droidbot-obtained']['add_dangerous_request'] = copy.deepcopy(label['Droidbot-obtained']['Dangerous'])
    for perm in requestPermissions:
        if perm not in label['Droidbot-obtained']['Dangerous'] and perm not in label['Droidbot-obtained']['Normal']:
            if perm in label['Declared']['All'][1]:
                label['Droidbot-obtained']['add_dangerous_request'][perm] = 0
            else:
                trace[perm] = requestPermissions[perm]['timestamp']
                label['Droidbot-obtained']['add_dangerous_request'][perm] = 1

    return label, trace


if __name__ == '__main__':
    # Create folders if not exist
    if not os.path.exists("logcats_filtered/"):
        os.makedirs("logcats_filtered/")
    if not os.path.exists("app/labels/"):
        os.makedirs("app/labels/")

    # Load the global permission and group mappings
    with open('malware/perm_group_pm.json') as map:
        perm_group_pm = json.load(map)

    # Read all the log files under logcats/
    logcats_lst = glob.glob("logcats/**/*.txt", recursive=True)
    pkg_dict = dict()
    pkg_list = list()
    for i in logcats_lst:
        # Extract package name and index from the file name
        # i represents file path, so it will be like logcats\pkg_idx_logcat.txt
        source_pkg = i.split("logcats\\")[1].split("_logcat")[0]
        print(source_pkg)
        source = source_pkg.split("\\")[0].strip()
        pkgName = source_pkg.split("\\")[1].strip()
        if source not in pkg_dict:
            pkg_dict[source] = [pkgName]
        else:
            pkg_dict[source].append(pkgName)

    for source_list in pkg_dict:
        for pkgName in pkg_dict[source_list]:
            logcat_path = "logcats\\%s\\%s_logcat.txt" % (source_list, pkgName)
            if not os.path.exists(logcat_path):
                continue

            # Read requests from file 'request.json'
            perm_requests = read_request()

            chk_path = "labels\\%s\\%s_label.json" % (source_list, pkgName)

            if os.path.exists(chk_path):
                continue
            print(pkgName)

            lines, pidList = read_logcat(source_list, pkgName)
            AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_mapping, label = parse(source_list, pkgName, lines, pidList)

            # If parsing index 1 logcats, we should read the requested permissions and groups from the perm_requests
            # Because if the permission or permission group is requested in the logcat_0 file,
            # then it should be referenced by the logcat_1 file
            perm_requests[pkgName] = [list(requestPermissions.keys()), list(requestPermGroups.keys())]
            label_all, trace_all = label_perm(AMS, AMS_normal, requestPermissions, requestPermGroups, perm_group_mapping, label)

            label_path = "labels/%s/%s_label.json" % (source_list, pkgName)
            trace_path = "trace/%s/%s_trace.json" % (source_list, pkgName)

            with open(label_path, 'w') as saved_labels:
                json.dump(label_all, saved_labels, indent=4)

            if not os.path.exists("trace/" + source_list):
                os.makedirs("trace/" + source_list)
            with open(trace_path, 'w') as saved_traces:
                json.dump(trace_all, saved_traces, indent=4)

            # Save requestPermissions and groups
            with open("request.json", "w") as req_save:
                json.dump(perm_requests, req_save, indent=4)



